---
import Separator from '../../core/separator.astro';
import Badge from '../../core/badge.astro';
import PopoverContent from '../../core/popover-content.astro';
import Button from '../../core/button.astro';

import {Astronav, Dropdown, DropdownItems} from "astro-navbar";
import { PlusCircled } from '@astropub/icons';

type IconType = typeof PlusCircled;

export interface Options {
  value: string;
  icon?: IconType;
}

interface Props {
  column?: string;
  title?: string;
  options: Options[];
}

const { column, title, options } = Astro.props as Props;
---
<div class="astronav-dropdown-menu" data-title={title}>
    <Astronav>
        <Dropdown class="relative" >
                <Button id=`toggle-popover-${column}` variant="outline" size="sm" className="h-8 border-dashed" data-popover-target="popover-default">
                    <PlusCircled class="mr-2 h-4 w-4" />
                    {title}
                        <>
                            <Separator  orientation="vertical" className="separator mx-2 h-4 hidden" id={title + "-separator"}/>
                            <Badge variant="secondary" size="sm" className="selected-count-badge rounded-sm px-1 font-normal lg:hidden">
                                <!-- This is where the count of the selected values will go -->
                            </Badge>
                            <div class="badge-container hidden space-x-1 lg:flex">
                                <!-- This is where the selected values will go -->
                            </div>
                        </>
                </Button>
                <DropdownItems class="border-secondary">
                    <PopoverContent title={title} options={options} className="w-[200px] p-0" align="start" />
                </DropdownItems>
        </Dropdown>
    </Astronav>
</div>


<script>
    //can't import badge variants for the badges in dropdown so need to manually assign className:
    const badgeClassSecondary : string = 'inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80 rounded-sm px-1 font-normal';

    let globalSelections: Object = {};

    document.addEventListener('DOMContentLoaded', () => {
        // Select all instances of the filters
        const dropdowns = document.querySelectorAll('.astronav-dropdown-menu'); 
        dropdowns.forEach(dropdown => {
            const title = dropdown.getAttribute('data-title');
            setupDropdown(dropdown, title);
            dropdown.addEventListener('click', (event) => {
                event.stopPropagation();
            });
        });
    });

    // differentiate between the filter categories of the different dropdowns, add event listeners to each
    function setupDropdown(dropdownElement: Element, title: string | null) {
        const optionElements = dropdownElement.querySelectorAll('.options-list li');
        let selectedOptions = new Set<string>();
        optionElements.forEach(element => {
			element.addEventListener('click', () => {
				const optionValue = element.getAttribute('data-value');
				if (optionValue !== null && title !== null) {
					toggleSelection(optionValue, selectedOptions, dropdownElement, title);
				}
			});
		});

        //select or de-select filter check-box
        const toggleSelection = (optionValue: string, selectedOptionsSet: Set<string>, dropdownElement: Element, title: string) => {
			const optionElement = dropdownElement.querySelector(`[data-checkboxValue="${optionValue}"]`);
            if (!optionElement) {
                return;
            }
            if (selectedOptionsSet.has(optionValue)) {
				selectedOptionsSet.delete(optionValue);
                toggleCheckBox(optionElement, false);   
			} else {
				selectedOptionsSet.add(optionValue);
                toggleCheckBox(optionElement, true);
			}
            globalSelections[title] = selectedOptionsSet;
			updateURLParams(globalSelections);
            updateDisplay(selectedOptionsSet, dropdownElement);
		};

        // update the display to add or remove selected filters to the badge
        const updateDisplay = (selectedValues: Set<string>, dropdownElement: Element) => {
            const badgeContainer = dropdownElement.querySelector('.badge-container');
            if (!badgeContainer) {
                return;
            }
            badgeContainer.innerHTML = '';

            // show separator if there are selected filters
            const separator = dropdownElement.querySelector('.separator');
            if (selectedValues.size === 0) {
                separator?.classList.add('hidden');
                return;
            }
            separator?.classList.remove('hidden');

            // update value of count badge
            const countBadge = dropdownElement.querySelector('.selected-count-badge');
            if (countBadge) {
                countBadge.textContent = selectedValues.size > 0 ? selectedValues.size.toString() : '';
            }

            // update the display of the selected filters
            if (selectedValues.size > 2) {
                const badge = document.createElement('div');
                badge.className = badgeClassSecondary;
                badge.textContent = `${selectedValues.size} selected`;
                badgeContainer.appendChild(badge);
            } else {
                selectedValues.forEach(value => {
                    const badge = document.createElement('div');
                    badge.className = badgeClassSecondary;
                    badge.textContent = value;
                    badgeContainer.appendChild(badge);
                });
            }
        }

        // update the filter parameters in the URL
		const updateURLParams = (selectedOptionsSet: Object) => {
			const searchParams = new URLSearchParams();
            Object.entries(selectedOptionsSet).forEach(([dropdownId, selectedValues]) => {
                selectedValues.forEach(value => {
                    searchParams.append(dropdownId, value);
                });
            });
			window.history.pushState(null, '', `?${searchParams}`);
		};

        //make style changes based off whether the filter is selected or not
        const toggleCheckBox = (optionElement: Element, checked: boolean) => {
            if (checked) {
                optionElement.classList.add('bg-primary', 'text-primary-foreground');
                optionElement.classList.remove('opacity-50', '[&_svg]:invisible');
            } else {
                optionElement.classList.remove('bg-primary', 'text-primary-foreground');
                optionElement.classList.add('opacity-50', '[&_svg]:invisible');
            }
        };
    }	
</script>